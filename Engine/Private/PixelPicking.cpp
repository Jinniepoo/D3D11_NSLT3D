#include "..\Public\PixelPicking.h"
#include "GameInstance.h"



CPixelPicking::CPixelPicking(ID3D11Device * pDevice, ID3D11DeviceContext * pContext)
	: m_pDevice { pDevice }
	, m_pContext { pContext }
	, m_pGameInstance { CGameInstance::Get_Instance() }
{
	Safe_AddRef(m_pGameInstance);
	Safe_AddRef(m_pDevice);
	Safe_AddRef(m_pContext);
}

HRESULT CPixelPicking::Initialize(HWND hWnd)
{
	m_hWnd = hWnd;

	/* 1. 셰이더에서 픽킹이 필요한 픽셀들의 깊이를 렌더타겟에 저장해준다. */
	/* 2. 렌더타겟텍스쳐로부터 깊이를 꺼내와서 월드위치를 계산한다. 단, 렌더타겟텍스쳐에서부터 직접 저장된 값을 꺼내올 수 없다.(D3D11_USAGE_DEFAULT)  */
	/* 3. 위의 렌더타겟을 다른 텍스쳐에 복사하고 복사받은 텍스쳐를 락언락해서 값을 꺼내와야지. */

	/* 3번에 해당하는 복사받을 텍스쳐를 미리 생성하여 준비한다. */
	D3D11_VIEWPORT			ViewportDesc{};
	_uint					iNumViewports = { 1 };
	m_pContext->RSGetViewports(&iNumViewports, &ViewportDesc);

	D3D11_TEXTURE2D_DESC		TextureDesc{};

	TextureDesc.Width = (_uint)ViewportDesc.Width;
	TextureDesc.Height = (_uint)ViewportDesc.Height;
	TextureDesc.MipLevels = 1;
	TextureDesc.ArraySize = 1;
	TextureDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;

	TextureDesc.SampleDesc.Quality = 0;
	TextureDesc.SampleDesc.Count = 1;

	TextureDesc.Usage = D3D11_USAGE_STAGING;
	TextureDesc.BindFlags = 0;
	TextureDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	TextureDesc.MiscFlags = 0;

	if (FAILED(m_pDevice->CreateTexture2D(&TextureDesc, nullptr, &m_pPickedDepthTexture)))
		return E_FAIL;

	m_fViewWidth = ViewportDesc.Width;
	m_fViewHeight = ViewportDesc.Height;

	return S_OK;
}

void CPixelPicking::Update()
{	
	/* 픽킹용 깊이를 기록해놓은 렌더타겟을 내가 열수있는 텍스쳐에 복사해준다. */
	/* 텍스쳐를 열어서 깊이를 얻어오는 작업이 가능해진거다. */
	if (FAILED(m_pGameInstance->Copy_RT_Resource(TEXT("Target_PickedDepth"), m_pPickedDepthTexture)))
		return;

	POINT		ptMouse{};

	GetCursorPos(&ptMouse);

	/* 뷰포트 상의 마우스 위치를 구했다. */
	/* 1. m_pPickedDepthTexture텍스쳐를 열어서 픽킹용 픽셀의 깊이를 얻어오는 작업을 할꺼야. */
	/* 2. 이픽셀은 몇개? (1280 * 720)이 만큼 있다.== 굉장히 많다. 마우스커서가 있는 위치의 픽셀 깊이하나를 얻어오고싶다. */
	/* 3. . 마우스커서가 있는 위치의 픽셀 깊이하나를 얻어오고싶다. == 
	_uint		iIndex = ptMouse.y * m_fViewWidth + ptMouse.x;*/
	/* 3. 위의 연산식은 언제썼떤거여? api때, 마우스 위치에 해당하는 타일의 인덱스 구하는 연산. */


	/* 1. 지금 구한 뷰포트 상의 마우스위치를 통해 월드스페이스 상의 마우스 위치를 구하기위한 과정에 활용이된다. */
	ScreenToClient(m_hWnd, &ptMouse);

	if (ptMouse.x < 0)
		ptMouse.x = 0;
	if (ptMouse.x >= (_long)m_fViewWidth)
		ptMouse.x = (_long)m_fViewWidth - 1;

	if (ptMouse.y < 0)
		ptMouse.y = 0;
	if (ptMouse.y >= (_long)m_fViewHeight)
		ptMouse.y = (_long)m_fViewHeight - 1;

	D3D11_MAPPED_SUBRESOURCE		SubResource{};

	/* 피킹용 깊이를 저장해놓은 테긋쳐를 연다! */
	m_pContext->Map(m_pPickedDepthTexture, 0, D3D11_MAP_READ, 0, &SubResource);

	_uint		iIndex = _uint(ptMouse.y * m_fViewWidth + ptMouse.x);

	/* 마우스 있는 위치의 픽셀 정보를 얻어오낟. */
	/* Out.vPickedDepth = vector(In.vProjPos.z / In.vProjPos.w, In.vProjPos.w / 3000.f, 0.f, 0.f); */

	_float4		vDepth = ((_float4*)SubResource.pData)[iIndex];

	m_pContext->Unmap(m_pPickedDepthTexture, 0);

	if (1.f == vDepth.w)
		return;

	/* ptMouse.x, ptMouse.y => 뷰포트 상의 위치다. 월드까지 역으로 연산을 해나가야한다. */

	/* 뷰포트상의 위치(0, 0) ~ (wsx, wsy) -> 투영스페이스 상의 위치(-1, 1) ~ (1, -1)르 ㄹ구하낟. */	
	m_vPickPos.x = ptMouse.x / (m_fViewWidth * 0.5f) - 1.f;
	m_vPickPos.y = ptMouse.y / (m_fViewHeight * -0.5f) + 1.f;
	m_vPickPos.z = vDepth.x;
	m_vPickPos.w = 1.f;	

	/* 투영공간상의 위치 -> 뷰스페이스 상의 위치르 ㄹ구하낟. */
	/* 역투영행렬을 바로 곱한 이유? -> 쉐이더에서 했다라면 바로 역투영행렬을 곱하면 안되었다. 나눴던 w를 곱해서 원근투영을 복구해주는 작업이 필요했엇다. */
	/* 쉐이더가아니라 클라. TransformCoord함수는 알아서 w연산ㅇ에 대한 처리를 해준다. */
	_matrix		ProjMatrixInv = m_pGameInstance->Get_Transform_Matrix_Inverse(CPipeLine::D3DTS_PROJ);
	_vector		vPickPos = XMVector3TransformCoord(XMLoadFloat4(&m_vPickPos), ProjMatrixInv);

	/* 뷰스페이스상의 위치 -> 월드 상의 위치르 ㄹ구하낟. */
	_matrix		ViewMatrixInv = m_pGameInstance->Get_Transform_Matrix_Inverse(CPipeLine::D3DTS_VIEW);
	vPickPos = XMVector3TransformCoord(vPickPos, ViewMatrixInv);
	
	m_bPixelPicked = true;

	XMStoreFloat4(&m_vPickPos, vPickPos);
}

CPixelPicking* CPixelPicking::Create(ID3D11Device * pDevice, ID3D11DeviceContext * pContext, HWND hWnd)
{
	CPixelPicking*	pInstance = new CPixelPicking(pDevice, pContext);

	if (FAILED(pInstance->Initialize(hWnd)))
	{
		MSG_BOX(TEXT("Failed to Created : CPixelPicking"));
		Safe_Release(pInstance);
	}

	return pInstance;
}
void CPixelPicking::Free()
{
	__super::Free();

	Safe_Release(m_pPickedDepthTexture);
	Safe_Release(m_pDevice);
	Safe_Release(m_pContext);

	Safe_Release(m_pGameInstance);

}
